// The good folks who wrote the below typings didn't write them to be importable as a module.
/// <reference types="emscripten" />

/**
 * This abstract type represents arrays allocated in a WebAssembly module,
 * where the byteOffset field is a pointer into THAT module.  Each
 * module should create its own nominal PTR_TYPE, e.g. by declaring
 * ```
 *   type MY_MODULES_NOMINAL_TYPE = enum {};
 *   type MY_MODULES_PTR_TYPE = number & MY_MODULES_NOMINAL_TYPE;
 * ```
 */
type HasPtr<PTR_TYPE extends number> = {byteOffset: PTR_TYPE}

/**
 * A Uint8Array where the byteOffset field is of type PTR_TYPE.
 * This is used to ensure that the byteOffset of an array that was not allocated
 * for your module is not passed as a pointer into your module.
 */
type Uint8ArrayWithPtrType<PTR_TYPE extends number> = Uint8Array & HasPtr<PTR_TYPE>

/**
 * This class encapsulates a WebAssembly module generated by Emscriptem
 * with functions to allocate raw pointers in that module's memory space
 * and pass them to functions that accept a raw pointer via a field defined
 * as type size_t.
 * 
 * To ensure memory used to pass or retrieve data from a WebAssembly module
 * is freed, it's best to use usingByteArray when receiving data from a module
 * and usingCopyOfArray when passing data to it.  Those methods allocate memory
 * for the lifetime of a callback (handling async callbacks by waiting for
 * promises to resolve or reject) before freeing memory.
 */
export class ModuleWithMemoryHelpers<MODULE_TYPE extends EmscriptenModule, PTR_TYPE extends number>{

    constructor(webasmModule: MODULE_TYPE) {
        this.webasmModule = webasmModule;
    }

    public readonly webasmModule: MODULE_TYPE

    /***
     * Allocate an Uint8Array  of size bytes of memory within the WebAssembly module.
     * To pass a pointer to this array to a WebAssembly function, use the the byteOffset field
     * as a pointer.
     *  
     * The caller is responsible for freeing this memory by calling free
     */
    public allocateU8 : (size: number) => Uint8ArrayWithPtrType<PTR_TYPE> =
        (size: number) => {
            const ptr = this.webasmModule._malloc(size);
            return this.webasmModule.HEAPU8.subarray(ptr, ptr + size) as Uint8ArrayWithPtrType<PTR_TYPE>;
        }

    /**
     * Free memory allocated via allocateU8.
     */
    public free = (array: Uint8ArrayWithPtrType<PTR_TYPE>) => {
        this.webasmModule._free(array.byteOffset);
    }

    /***
     * Create a byte array in the module's memory which lives for the lifetime
     * of a callback and is freed immediately when the callback completes or
     * exits via an exception.
     * 
     * If the callback returns an object that is an instance of Promise, the
     * memory will live until the promise completes or an exception is thrown.
     */
    public usingByteArray = async (
        arrayLengthInbytes: number,
        callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<PTR_TYPE>) => unknown
    ) => {
        var array = this.allocateU8(arrayLengthInbytes);
        try {
            const result = callback(array);
            if (typeof(result) === "object" && result instanceof Promise) {
                await(result);
            }
        } finally {
            this.free(array);
        }
    }

    /***
     * Create a copy of an array in memory accessible to the WebAssembly module
     * during the lime of the callback.  The lifetime semantics are the same as
     * usingByteArray.
     */
    public usingCopyOfArray = (
        fromArray: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array,
        callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<PTR_TYPE>) => unknown
    ) => this.usingByteArray(fromArray.length * fromArray.BYTES_PER_ELEMENT, (newArray) => {
        newArray.set(fromArray);
        return callback(newArray);
    });

};
