// The good folks who wrote the below typings didn't write them to be importable as a module.
/// <reference types="emscripten" />

type WebAssemblyModule = EmscriptenModule;
export type {WebAssemblyModule};

/**
 * This abstract type represents arrays allocated in a WebAssembly module,
 * where the byteOffset field is a pointer into THAT module.  Each
 * module should create its own nominal PTR_TYPE, e.g. by declaring
 * ```
 *   type MY_MODULES_NOMINAL_TYPE = enum {};
 *   type MY_MODULES_PTR_TYPE = number & MY_MODULES_NOMINAL_TYPE;
 * ```
 */
type HasPtr<INTRA_MODULE_PTR_TYPE extends number> = {byteOffset: INTRA_MODULE_PTR_TYPE}

/**
 * A Uint8Array where the byteOffset field is of type INTRA_MODULE_PTR_TYPE.
 * This is used to ensure that the byteOffset of an array that was not allocated
 * for your module is not passed as a pointer into your module.
 * 
 */
export type Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE extends number> = Uint8Array & HasPtr<INTRA_MODULE_PTR_TYPE>

export interface TypedMemoryHelpersForEmscriptenModule<INTRA_MODULE_PTR_TYPE extends number = number> {
  tsMemory: {
    /***
     * Allocate an Uint8Array  of size bytes of memory within the WebAssembly module.
     * To pass a pointer to this array to a WebAssembly function, use the the byteOffset field
     * as a pointer.
     *  
     * The caller is responsible for freeing this memory by calling free
     */
    allocateU8 : (size: number) => Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>;

    /**
     * Free memory allocated via allocateU8.
     */
    freeU8: (array: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => void;

  /***
   * Create a byte array in the module's memory which lives for the lifetime
   * of a callback and is freed immediately when the callback completes or
   * exits via an exception.
   * 
   * If the callback returns an object that is an instance of Promise, the
   * memory will live until the promise completes or an exception is thrown.
   */
    usingByteArray: <T>(
        arrayLengthInbytes: number,
        callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => T
    ) => T;

    /***
   * Create a copy of an array in memory accessible to the WebAssembly module
   * during the lime of the callback.  The lifetime semantics are the same as
   * usingByteArray.
   */
    usingCopyOfArray: <T>(
        fromArray: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array,
        callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => T
    ) => T;
  }
}

/**
 * This function wrapa WebAssembly module generated by Emscriptem
 * with functions to allocate raw pointers in that module's memory space
 * and pass them to functions that accept a raw pointer via a field defined
 * as type size_t.
 * 
 * To ensure memory used to pass or retrieve data from a WebAssembly module
 * is freed, it's best to use usingByteArray when receiving data from a module
 * and usingCopyOfArray when passing data to it.  Those methods allocate memory
 * for the lifetime of a callback (handling async callbacks by waiting for
 * promises to resolve or reject) before freeing memory.
 */
export function addTsMemoryToModule<MODULE extends EmscriptenModule, INTRA_MODULE_PTR_TYPE extends number>(
  module: MODULE
) : MODULE & TypedMemoryHelpersForEmscriptenModule<INTRA_MODULE_PTR_TYPE> {

  const allocateU8 = (size: number) => {
      const ptr = module._malloc(size);
      return module.HEAPU8.subarray(ptr, ptr + size) as Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>;
  };

  const freeU8 = (array: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => {
    module._free(array.byteOffset);
  };

  const usingByteArray = <T>(
    arrayLengthInbytes: number,
    callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => T
  ): T => {
    // We'll have two different mechanisms for freeing allocated memory, depending
    // on whether the callback is an async function which should not be treated as
    // complete until the promise it returns has completed.
    var memoryCannotBeFreedUntilAsyncCallbackCompletes = false;

    // Allcoate the memory that we'll want to ensure is freed after the callback completes
    var array = allocateU8(arrayLengthInbytes);

    // For non-async callbacks, this try-finally block will ensure that we can free memory
    // regardless of whether the callback compltes successfully or even if an exception is thrown.
    try {
      // Call the caller's provided callback so it can use the array we've allocated.
      const result = callback(array);

      // Now we can test if the callback is an async function by seeing if it returned a promise.
      if (typeof(result) === "object" && result instanceof Promise) {
        // make sure we de-allocate the memory AFTER the callback's promise completes
        result.finally( () => {
          freeU8(array);
        })
        // Since this is not an async function (it can't return a promise unless the callback
        // returns a promise) the finally block below will run before the async callback completes.
        // Make sure the finally block below does not de-allocate the memory while the async
        // callback is still using it.  The finally call above will free it instead.
        memoryCannotBeFreedUntilAsyncCallbackCompletes = true;
      }

      // We return the result of the callback to the caller.
      // If the callback was a async function, we return the (still unresolved) promise,
      // since we're not waiting for it.
      return result;
    } finally {
      // Make sure to free the memory we allocated
      // (unless we're returning a Promise, in which case we'll do it later via promise.finally).
      if (!memoryCannotBeFreedUntilAsyncCallbackCompletes) {
        freeU8(array);
      }
    }
  };

  const usingCopyOfArray = <T>(
    fromArray: Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array,
    callback: (arrayCopiedIntoCppAccessibleBlock: Uint8ArrayWithPtrType<INTRA_MODULE_PTR_TYPE>) => T
  ) => usingByteArray(fromArray.length * fromArray.BYTES_PER_ELEMENT, (newArray) => {
      newArray.set(fromArray);
      return callback(newArray) as T;
  });

  return Object.assign( module, { tsMemory: {allocateU8, freeU8, usingByteArray, usingCopyOfArray } });
};

/**
 * Take the default export of an Emscriptem module and turn it into a promise for a copy
 * of the module, augmented with our TypeScript methods for using memory in the webasm module.
 *
 * @param functionReturningASadAndBuggyExcuseForAModulePromise That which emscriptem exports in modules
 * has been given a then function to look like a promise, but treating it like a promise yields an
 * infinite loop.  Don't worry, just pass that sh*t here and we'll fix it for you.
 * (For more info, see https://github.com/emscripten-core/emscripten/issues/5820 and how we've
 * implemented this.)
 */
export const getWebAsmModulePromiseWithAugmentedTypes = <MODULE extends EmscriptenModule, PTR extends number>
  (
    functionReturningASadAndBuggyExcuseForAModulePromise: () => {then: (callback: (module: MODULE) => unknown) => unknown}
  ): Promise<MODULE & TypedMemoryHelpersForEmscriptenModule<PTR>> =>
    new Promise<MODULE & TypedMemoryHelpersForEmscriptenModule<PTR>> (
      (resolveModule, reject) => {
      try {
        functionReturningASadAndBuggyExcuseForAModulePromise().then( (module: MODULE) => {
          // The good folks at emscripten didn't understand promises when they decided to make their
          // modules look kindof like promises to return modules and augmenting them with a .then()
          // method.  Alas, rather than the then() returning the module, the then() was just another
          // field on the object, and so if you awaited it you'd be stuck in an infinite loop of
          // calls to then.  This hack in the next line, removing the then() method after it is called,
          // fixes it until the fix from them is released and likely to be in the toolchain of
          // anyone who might build this.
          //
          // https://github.com/emscripten-core/emscripten/issues/5820
          delete (module as unknown as {then: any})['then'];
          resolveModule(addTsMemoryToModule(module));
        });
      } catch (e) {
          reject(e);
      }
    }
  );